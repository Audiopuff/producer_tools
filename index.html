<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Processing Service</title>
    <style>
        /* Existing styles - no changes needed here */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f8f8;
            padding: 20px;
        }
        .container { max-width: 800px; margin: 0 auto; padding: 20px; }
        h1, h2, h3 { margin-bottom: 20px; text-align: center; }
        .upload-form, .status, .result, .how-to-use {
            background-color: white; border-radius: 5px; padding: 20px;
            margin-bottom: 20px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .file-input { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="file"] {
            display: block; width: 100%; padding: 10px;
            border: 1px solid #ddd; border-radius: 4px; margin-bottom: 15px;
        }
        /* Progress Bar Style */
        .progress-bar-container {
            width: 100%;
            background-color: #f3f3f3;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 15px;
            height: 25px; /* Set a height */
            overflow: hidden; /* Hide overflow */
            display: none; /* Hidden by default */
        }
        .progress-bar {
            width: 0%;
            height: 100%; /* Fill container height */
            background-color: #4CAF50;
            text-align: center;
            line-height: 25px; /* Center text vertically */
            color: white;
            font-size: 12px;
            transition: width 0.4s ease;
        }
        /* Button Style */
        button {
            display: block; width: 100%; padding: 10px; background-color: #4CAF50;
            color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px;
        }
        button:hover { background-color: #45a049; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; } /* Disabled state */
        .status, .result { text-align: center; }
        .processed-file {
            margin-bottom: 30px; padding: 15px; border: 1px solid #eee;
            border-radius: 5px; background-color: #fafafa;
        }
        .processed-file h3 { margin-bottom: 15px; color: #333; font-size: 1.2em; }
        audio { width: 100%; margin: 20px 0; }
        .download-link { margin-top: 15px; }
        .download-link a {
            display: inline-block; padding: 10px 15px; background-color: #2196F3;
            color: white; text-decoration: none; border-radius: 4px; margin: 0 5px;
            transition: background-color 0.3s ease;
        }
        .download-link a:hover { background-color: #0b7dda; }
        .processing-stage { margin-top: 10px; font-style: italic; color: #666; }
        .how-to-use ul { list-style-type: disc; margin-left: 20px; margin-top: 10px; }
        .how-to-use li { margin-bottom: 8px; }
        .important-note { color: #d32f2f; font-weight: bold; margin-top: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Audio Processing Service</h1>

        <div class="how-to-use">
            <h2>How to Use</h2>
            <ul>
                <li>This service works best with music containing bass, drums, and vocals.</li>
                <li>MP3, WAV, FLAC, AIF, AIFF files are accepted.</li>
                <li>Large files may take time to upload directly to storage.</li>
                <li>Backend processing can take up to 30 minutes after upload.</li>
                <li>Keep this browser window open during the direct upload phase.</li>
            </ul>
            <p class="important-note">Important: You can close this window *after* the "Finalizing upload..." message appears and processing starts on the backend.</p>
        </div>

        <div class="upload-form">
            <h2>Upload Audio File</h2>
            <form id="uploadForm">
                <div class="file-input">
                    <label for="audioFile">Audio File (MP3, WAV, FLAC, AIF, AIFF):</label>
                    <!-- Updated accept attribute -->
                    <input type="file" id="audioFile" accept=".mp3,.wav,.flac,.aif,.aiff" required>
                    <p style="color: #666; font-size: 0.9em; margin-top: 5px;">Select your audio file.</p>
                </div>
                 <!-- Progress Bar -->
                <div class="progress-bar-container" id="progressBarContainer">
                    <div class="progress-bar" id="progressBar">0%</div>
                </div>
                <button type="submit" id="uploadButton">Upload and Process</button>
            </form>
        </div>
        <div class="status" id="statusContainer">
            <p id="statusMessage"></p>
            <p id="processingStage" class="processing-stage"></p>
        </div>
        <div class="result" id="resultContainer" style="display: none;">
            <h2>Processed Audio</h2>
            <div class="processed-file">
                <h3>Processed Audio</h3>
                <!-- Audio player will be populated by download link click -->
                <p>Click the download link below to get your file.</p>
                <!-- <audio id="processedAudio" controls></audio> -->
                <div class="download-link">
                    <!-- The link will be updated by JavaScript -->
                    <a id="downloadLink" href="#" download="processed_audio.wav">Download Processed Audio</a>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const uploadForm = document.getElementById('uploadForm');
            const uploadButton = document.getElementById('uploadButton');
            const statusMessage = document.getElementById('statusMessage');
            const processingStage = document.getElementById('processingStage');
            const resultContainer = document.getElementById('resultContainer');
            const progressBarContainer = document.getElementById('progressBarContainer');
            const progressBar = document.getElementById('progressBar');
            const audioFileInput = document.getElementById('audioFile');

            // Get the trigger service URL from environment or use default
            // Ensure this points to your *ap_main* service URL
            const backendBaseUrl = window.TRIGGER_SERVICE_URL || 'https://apmainrefac-1053060340132.us-central1.run.app/';
            const initiateUrl = backendBaseUrl + 'initiate_upload';
            const finalizeUrl = backendBaseUrl + 'finalize_upload';
            const statusUrlBase = backendBaseUrl + 'status/';
            const downloadUrlBase = backendBaseUrl + 'download/'; // Base for *triggering* the file download

            uploadForm.addEventListener('submit', async function(e) {
                e.preventDefault();
                resetUI(); // Reset UI elements

                const file = audioFileInput.files[0];
                if (!file) {
                    statusMessage.textContent = 'Please select an audio file.';
                    return;
                }

                // Disable button, show progress bar
                uploadButton.disabled = true;
                uploadButton.textContent = 'Starting Upload...';
                progressBarContainer.style.display = 'block';
                progressBar.style.width = '0%';
                progressBar.textContent = '0%';
                statusMessage.textContent = 'Initiating upload...';

                const filename = file.name;
                const contentType = file.type || 'application/octet-stream';

                try {
                    // 1. Initiate Upload
                    console.log(`Initiating upload for ${filename} (${contentType})`);
                    const initiateResponse = await fetch(initiateUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ filename, contentType }),
                    });

                    if (!initiateResponse.ok) {
                        let errorText = `HTTP error ${initiateResponse.status}`;
                        try {
                           const errorData = await initiateResponse.json();
                           errorText = `Failed to initiate upload: ${errorData.error || initiateResponse.statusText}`;
                        } catch (e) {
                            errorText = `Failed to initiate upload: ${initiateResponse.statusText || errorText}`;
                        }
                        throw new Error(errorText);
                    }

                    const { jobId, signedUrl, gcsPath, filename: returnedFilename } = await initiateResponse.json();
                    console.log(`[${jobId}] Received Signed URL for ${returnedFilename}. Uploading directly to GCS...`);
                    statusMessage.textContent = `Uploading ${returnedFilename}...`;

                    // 2. Direct Upload to GCS using XMLHttpRequest for progress
                    await uploadDirectlyToGCS(jobId, signedUrl, file, contentType);

                    console.log(`[${jobId}] GCS upload successful.`);
                    statusMessage.textContent = 'Upload complete. Finalizing...';
                    progressBar.style.width = '100%';
                    progressBar.textContent = 'Finalizing...';

                    // 3. Notify Backend of Completion
                    const finalizeResponse = await fetch(finalizeUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ jobId, gcsPath, originalFilename: filename }),
                    });

                    if (!finalizeResponse.ok) {
                        let errorText = `HTTP error ${finalizeResponse.status}`;
                        try {
                            const errorData = await finalizeResponse.json();
                            errorText = `Failed to finalize upload: ${errorData.error || finalizeResponse.statusText}`;
                        } catch (e) {
                            errorText = `Failed to finalize upload: ${finalizeResponse.statusText || errorText}`;
                        }
                        throw new Error(errorText);
                    }

                    const finalizeResult = await finalizeResponse.json();
                    console.log(`[${jobId}] Upload finalized by backend. Status: ${finalizeResult.status}`);
                    statusMessage.textContent = 'Processing started...';
                    processingStage.textContent = 'Queued'; // Initial backend status

                    // 4. Start Polling for Backend Processing Status
                    pollProcessingStatus(jobId);

                } catch (error) {
                    console.error("Upload process failed:", error);
                    statusMessage.textContent = `Error: ${error.message}`;
                    resetUploadButton();
                    progressBarContainer.style.display = 'none';
                }
            });

            function uploadDirectlyToGCS(jobId, url, file, contentType) {
                return new Promise((resolve, reject) => {
                    const xhr = new XMLHttpRequest();
                    xhr.open('PUT', url, true);
                    xhr.setRequestHeader('Content-Type', contentType);

                    xhr.upload.onprogress = function(event) {
                        if (event.lengthComputable) {
                            const percentComplete = Math.round((event.loaded / event.total) * 100);
                            progressBar.style.width = percentComplete + '%';
                            progressBar.textContent = percentComplete + '%';
                            // console.log(`[${jobId}] Upload Progress: ${percentComplete}%`); // Optional: less verbose logging
                        }
                    };

                    xhr.onload = function() {
                        if (xhr.status >= 200 && xhr.status < 300) {
                            resolve(xhr.response);
                        } else {
                            // Try to get a more specific error from GCS response if available
                            let gcsError = xhr.responseText || `Status ${xhr.status}`;
                            if (xhr.responseXML) { // GCS often returns XML errors
                                try {
                                    const errorNodes = xhr.responseXML.getElementsByTagName('Message');
                                    if (errorNodes.length > 0) {
                                        gcsError = errorNodes[0].textContent;
                                    }
                                } catch (e) { /* Ignore parsing errors */ }
                            }
                            reject(new Error(`GCS upload failed: ${gcsError}`));
                        }
                    };

                    xhr.onerror = function() {
                        reject(new Error('Network error during GCS upload.'));
                    };

                    xhr.send(file);
                });
            }


            async function pollProcessingStatus(jobId) {
                const statusUrl = statusUrlBase + jobId;
                 console.log(`[${jobId}] Polling status: ${statusUrl}`);
                 try {
                    const response = await fetch(statusUrl);
                     if (!response.ok) {
                         let errorText = `Failed to get status (${response.status})`;
                         try {
                            const errorData = await response.json();
                            errorText = errorData.error || `HTTP error ${response.status}`;
                         } catch (e) {
                             errorText = `Failed to get status: ${response.statusText || response.status}`;
                         }
                         throw new Error(errorText);
                     }
                    const data = await response.json();
                    console.log(`[${jobId}] Status received:`, data.status);

                    if (data.status === 'failed') {
                        statusMessage.textContent = 'Processing failed.';
                        processingStage.textContent = `Error: ${data.error || 'Unknown error'}`;
                        resetUploadButton();
                        progressBarContainer.style.display = 'none'; // Hide progress bar on fail
                    } else if (data.status === 'completed') {
                        statusMessage.textContent = 'Processing completed!';
                        processingStage.textContent = '';
                        progressBarContainer.style.display = 'none'; // Hide progress bar on success

                        // --- **MODIFICATION POINT** ---
                        // Generate the filename the backend would suggest
                        const originalFilename = data.original_filename || 'output.wav';
                        const baseName = originalFilename.substring(0, originalFilename.lastIndexOf('.')) || originalFilename;
                        const downloadFilename = `${baseName}_final_audiopuff.wav`; // Construct the name

                        // Update the download link to point *directly* to the download endpoint
                        const downloadUrl = downloadUrlBase + jobId; // URL that serves the file
                        const downloadLink = document.getElementById('downloadLink');

                        downloadLink.href = downloadUrl; // Set href to trigger download from backend
                        downloadLink.download = downloadFilename; // Set the desired filename
                        downloadLink.textContent = `Download ${downloadFilename}`;
                        downloadLink.onclick = null; // Remove any previous handler
                        // No need for the fetchAndSetDownloadLink function anymore for the *final* file

                        console.log(`[${jobId}] Download link set to trigger download for ${downloadFilename} from ${downloadUrl}`);
                        resultContainer.style.display = 'block'; // Show results
                        resetUploadButton();
                        // --- **END MODIFICATION** ---

                    } else {
                        statusMessage.textContent = 'Processing audio file...';
                        // Display more detailed stage info if available
                        let stageText = data.status ? data.status.replace(/_/g, ' ') : 'In progress'; // Basic status
                        if (data.pipeline_stages) {
                             const stages = data.pipeline_stages;
                             const stageOrder = ['delimit', 'mvsep', 'stem_processing', 'ducking', 'normalization', 'combination', 'instcut', 'final_mix', 'two_bus'];
                             let currentStageDesc = '';
                             for (const stageKey of stageOrder.slice().reverse()) { // Find the last non-skipped/failed stage
                                 const stageStatus = stages[stageKey];
                                 if (stageStatus && stageStatus !== 'skipped' && stageStatus !== 'failed') {
                                     currentStageDesc = `${stageKey.replace('_', ' ')} (${stageStatus})`;
                                     break;
                                 }
                             }
                             if (currentStageDesc) {
                                 stageText = `Stage: ${currentStageDesc}`;
                             }
                        }
                         processingStage.textContent = stageText;
                        // Continue polling
                        setTimeout(() => pollProcessingStatus(jobId), 5000); // Poll every 5 seconds
                    }
                 } catch (error) {
                    console.error(`[${jobId}] Error polling status:`, error);
                    statusMessage.textContent = 'Error checking status.';
                    processingStage.textContent = `Details: ${error.message}`;
                    resetUploadButton();
                    progressBarContainer.style.display = 'none';
                 }
            }

            // --- **REMOVED fetchAndSetDownloadLink function - No longer needed for the final download** ---
            // async function fetchAndSetDownloadLink(jobId, suggestedFilename) { ... }

            function resetUI() {
                statusMessage.textContent = '';
                processingStage.textContent = '';
                resultContainer.style.display = 'none';
                progressBarContainer.style.display = 'none';
                progressBar.style.width = '0%';
                progressBar.textContent = '0%';
                // Reset download link state
                const downloadLink = document.getElementById('downloadLink');
                downloadLink.textContent = 'Download Processed Audio';
                downloadLink.href = '#'; // Reset href
                downloadLink.removeAttribute('download'); // Remove download attribute
                downloadLink.onclick = (e) => e.preventDefault(); // Prevent click initially
            }

            function resetUploadButton() {
                 uploadButton.disabled = false;
                 uploadButton.textContent = 'Upload and Process';
            }

        });
    </script>
</body>
</html>
